head	1.23;
access;
symbols;
locks
	case:1.23; strict;
comment	@ * @;


1.23
date	2013.06.08.06.14.41;	author case;	state Exp;
branches;
next	1.22;

1.22
date	2013.06.04.08.14.58;	author case;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.04.08.12.25;	author case;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.31.19.41.27;	author case;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.07.23.31.34;	author case;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.07.21.34.21;	author case;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.07.01.12.30;	author case;	state Exp;
branches;
next	1.16;

1.16
date	2013.05.06.04.40.23;	author case;	state Exp;
branches;
next	1.15;

1.15
date	2013.05.06.04.19.00;	author case;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.04.18.03.33;	author case;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.04.16.50.17;	author case;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.04.02.41.06;	author case;	state Exp;
branches;
next	1.11;

1.11
date	2013.05.03.03.46.50;	author case;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.29.18.58.23;	author case;	state Exp;
branches;
next	1.9;

1.9
date	2013.04.29.18.03.48;	author case;	state Exp;
branches;
next	1.8;

1.8
date	2013.04.29.14.10.32;	author case;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.29.04.25.33;	author case;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.28.08.56.12;	author case;	state Exp;
branches;
next	1.5;

1.5
date	2013.04.28.07.20.22;	author case;	state Exp;
branches;
next	1.4;

1.4
date	2013.04.27.04.22.27;	author case;	state Exp;
branches;
next	1.3;

1.3
date	2013.04.03.03.25.15;	author case;	state Exp;
branches;
next	1.2;

1.2
date	2013.04.03.00.03.39;	author case;	state Exp;
branches;
next	1.1;

1.1
date	2013.04.02.23.56.39;	author case;	state Exp;
branches;
next	;


desc
@Silly NetBSD tricks. Grab frames with libpcap and dump values to
speaker driver.
@


1.23
log
@Fixed sample format, tweaked buffer size. Last checkin before linking in tonegenerator.c and using simpler interface to encapsulate portaudio.
@
text
@/* Thanks to networksorcery.com. This valuable resource saved me much time. Without them
   I would have had to wade through a LOT of RFC's. Their hypertext breakdowns of every 
   protocol imaginable, along with diagrams, made this much easier.	The info is out there
   in other places, but I've never seen a better centralized comprehensive reference.		 */

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <limits.h>
#include <arpa/inet.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#define DEBUG 1
/*#include <netinet/in_systm.h>*/ /* required by ip_icmp.h */
/* #include <netinet/ip_icmp.h> */

/* The BSD's have diverged in where they keep headers for esr's
   speaker driver (or perhaps it was backported; not sure if it was
   in 386BSD. */
#ifdef __NETBSD__
#define __BSD_SPEAKER__
#include <machine/spkr.h>
#endif

#ifdef __OPENBSD__
#define __BSD_SPEAKER__
#include <sys/ioctl.h>
#include <dev/isa/spkrio.h>
#include <pcap.h>
#else
#include <pcap/pcap.h>
#endif 

#ifdef __FREEBSD__
#define __BSD_SPEAKER__
#include <dev/speaker/speaker.h>
#endif

#ifdef __LINUX__
#include <portaudio.h>
#include <math.h> /* sin() etc for waveform tone generation */
#endif


#include "pcaptoy.h"


#define MAX_FUNC_LEN 		1024 /* max length of function name strings */
#define PCAPTOY_BUFFSIZE	8192 /* buffer for queued packets. Additional 
									packets will be dropped. Keep it low for
									this toy program. */
#define PCAPTOY_INF			-1	/* capture indefinitely */
#define PCAPTOY_CAPCOUNT	50
#define PCAPTOY_VERBOSE		1
#define PCAPTOY_TIMEOUT		500 	/* ms? */

/* older native pcap on OpenBSD doesn't have this constant. 
   TODO: test filtering on OpenBSD */
#ifdef __OPENBSD__
	#define PCAPTOY_NETMASK_UNKNOWN 0
#else
	#define PCAPTOY_NETMASK_UNKNOWN PCAP_NETMASK_UNKNOWN
#endif

#define PCAPTOY_BUFFERING	_IONBF /*TODO replace with cmd line opt */

/* values to play with for speaker note duration */
/* might should put the speaker stuff in a separate module, 
   to maximize code reuse. We can build other toys for other
   platforms based on this module, maybe... */

#define PCAPTOY_NOTEDURATION_HEADER		50
#define PCAPTOY_NOTEDURATION_PAYLOAD	50

/* arrrgh not working, forget it for now */
#if 0
/* use -DCHATTY=1 */
#ifdef CHATTY
#define VERBOSE( v_msg ) {(\
if (CHATTY) 			\
	printf( (v_msg) )			\
)}
#else
#define VERBOSE ( v_msg ) {()}
#endif

/* code in here for errno? */
#define ERR (e_str)	{(	 \
	fprintf(stderr, (e_str) ) \
)}
#endif /* end if 0 */

/* userdata struct for pcap callback */
typedef struct {
	char invok[PATH_MAX+1]; /* TODO: replace w/ runtime pathconf() and dynamic alloc */
	FILE *out; 		/* normally stdout 	*/
	FILE *err; 		/* stderr 			*/
	int fd_spkr; 	/* descriptor for speaker device */

#ifdef __LINUX__ /* getting messy quick */
	#define SAMPLE_RATE 44100
	#define FRAMES_PER_BUFFER 128
	#define WAVETABLE_SIZE 100
	PaStream *pa;

	float sine[WAVETABLE_SIZE];
	int sine_lphase;
	int sine_rphase;
#endif

	long count;
} handler_state;

int InitAudio(handler_state *phs); /* stub in everything but Linux */
void DeInitAudio();

#ifdef __LINUX__
int InitAudioLinux(handler_state *phs);
void DeInitAudioLinux();
#endif
			   

/* print diagnostic messages from pcap return codes */
int print_diag_pcap_options(int pcap_ret, const char *func, const handler_state *hs);

/* print diagnostics for pcap_activate() errors */
int print_diag_pcap_activate(pcap_t *p, int pcap_ret, const handler_state *invok);

/* forward declaration of pcap_handler for callback*/
void handle_packet(u_char *user, const struct pcap_pkthdr *h,
					const u_char *raw);

/* callback will call these functions conditionally. Args TBD */
void handle_packet_print(handler_state *phs,
							const struct pcap_pkthdr *h,
							const u_char *raw);
void handle_packet_spkr(handler_state *phs,
							const struct pcap_pkthdr *h,
							const u_char *raw);
void handle_packet_spkr_array(handler_state *phs,
							const struct pcap_pkthdr *h,
							const u_char *raw);

#ifdef __LINUX__
typedef struct {int frequency; int duration;} tone_t;
void output_array_portaudio(handler_state *phs, tone_t *tones);
#endif

/* loop functions which pass through args to pcap handle errors appropriately */
int do_pcap_loop	(pcap_t *p, int cnt, pcap_handler h, handler_state *phs);
int do_pcap_dispatch(pcap_t *p, int cnt, pcap_handler h, handler_state *phs);

/* TESTING ONLY! REMOVE! */
unsigned short testfreq = 20;

int main(int argc, char** argv) {
	int verbose = PCAPTOY_VERBOSE; /* TODO: arg */
	/*int fd_log  = STDOUT_FILENO;
	int fd_err  = STDOUT_FILENO;*/
	/*FILE *fp_log = stdout;
	FILE *fp_err = stderr;*/

  	int ret = 0; 	/* main() return code */
	int pc_ret = 0; /* return codes from libpcap */
 	pcap_t *p;	 	/* pcap handle */
	handler_state hs;

	/* bytes to capture. Could make this a command-line arg. Do we want
	   payload or just headers? */
	int framelen = 1024; 
	int promisc  = 0;   /* TODO: command-line arg */
	int read_timeout  	= PCAPTOY_TIMEOUT; /* read timeout in ms */
	int pc_bufsize 		= PCAPTOY_BUFFSIZE;

	/* TODO: be more sophisticated, copy arg */
	const char * szdev = argv[1];
	struct bpf_program filter;
	char errbuf[PCAP_ERRBUF_SIZE]; /* for pcap to give us info */ 
	char funcbuf[MAX_FUNC_LEN];
	memset(&filter, '\0', sizeof(filter));
	memset(errbuf, '\0', PCAP_ERRBUF_SIZE);
	memset(funcbuf, '\0', MAX_FUNC_LEN);
	hs.count = 0;
	strncpy(hs.invok, argv[0], PATH_MAX);
	hs.invok[PATH_MAX] = '\0';
	hs.out = stdout;
	hs.err = stderr;
	hs.fd_spkr = open("/dev/speaker", O_WRONLY);
	hs.pa = NULL;

	/* do some input validation; ensure we can continue */
	if (!(argc-1)) {
		fprintf(hs.err, "%s: No interface specified!\n", hs.invok);
		fprintf(hs.err, "usage: %s <interface>\n", hs.invok);
		ret = 1;
		exit(ret);
	}

 	printf("pcaptoy - coydog's silly libpcap/NetBSD tricks.\n\n");
	if (verbose) {
		fprintf(hs.out, "Initializing, getting pcap handle for >%s<\n",
						szdev);
	}
	/* if we wanted to read from a previous capture, we could call
	   pcap_open_offline() here instead.							*/

	/* audio initialization - (portaudio on linux) */
	if (!InitAudio(&hs))
		exit(1);
			
	if ( !(p = pcap_create(szdev, errbuf))) {
		fprintf(hs.err, "pcap_create() failed!: \n");
		fprintf(hs.err, errbuf);
		if (verbose) 
			fprintf(hs.out, "pcap_create() error, bailing\n");
		
		ret = 1;
		exit(ret);	
	}
	else if (verbose) 
		fprintf(hs.out, "pcap_create() success, continuing.\n");

	/* set capture handle options */
	pc_ret = pcap_set_snaplen(p, framelen); /* capture length */
	snprintf(funcbuf, MAX_FUNC_LEN, "pcap_set_snaplen(%d, %d)", 
					(int)p, 
					framelen);
	print_diag_pcap_options(pc_ret, funcbuf, &hs);
	if (pc_ret != 0) {						/* 0 is success */
		/*print_diag_pcapreturn(pc_ret, funcbuf, argv[0]);*/
		fprintf(hs.err, "%s: can't set snapshot length, bailing!\n", hs.invok);
		ret = 1;
		exit(ret);
	} else if (verbose) {
		fprintf(hs.out, "Successfully set snapshot len to %d, continuing...\n",
					framelen);
	}
	pc_ret = pcap_set_promisc(p, promisc); 	/* promiscuous mode */
	snprintf(funcbuf, MAX_FUNC_LEN, "pcap_set_promisc(%d, %d)",
					(int)p,
					promisc);
	print_diag_pcap_options(pc_ret, funcbuf, &hs);
	if (pc_ret != 0) {
		fprintf(hs.err, "%s: can't set promisc flag, bailing!\n", hs.invok);
		ret = 1;
		exit (ret);
	} else if (verbose) {
		fprintf(hs.out, "Successfully set promiscuous flag to %d, "
						"continuing...\n",
						promisc);
	}
	/* TODO: handle 802.11-specific stuff with pcap_set_rfmon() and
	   	pcap_can_set_rfmon(). accept default for now.	*/

	/* set read timeout. If OS and pcap are queueing up packets for us, 
	   but network traffic is slow and we want to work with the packets
	   we already have, set this timeout so that we don't wait indefinitely
	   for enough packets to arrive. Timeout will not start until a packet
 	   arrives.	 */
	pc_ret = pcap_set_timeout(p, read_timeout);
	snprintf(funcbuf, MAX_FUNC_LEN, "pcap_set_timeout(%d, %d)",
			(int)p,
			read_timeout);
	print_diag_pcap_options(pc_ret, funcbuf, &hs);
	if (pc_ret != 0) {
		fprintf(hs.out, "%s: can't set read timeout, bailing!\n", hs.invok);
		ret = 1;
		exit(ret);
	} else if (verbose) {
		fprintf(hs.out, "Successfully set read timeout to %d, continuing...\n",
					read_timeout);
	}

	/* set capture buffer size */
	pc_ret = pcap_set_buffer_size(p, pc_bufsize);
	snprintf(funcbuf, MAX_FUNC_LEN, "pcap_set_buffer_size(%d, %d)",
					(int)p,
					pc_bufsize);
	print_diag_pcap_options(pc_ret, funcbuf, &hs);
	if (pc_ret != 0) {
		fprintf(hs.err, "%s: can't set pcap buffer size, bailing!\n", hs.invok);
		ret = 1;
		exit(ret);
	} else if (verbose) {
		fprintf(hs.out, "Successfully set pcap buffer size to %d, "
						"continuing...\n",
						pc_bufsize);
	}

	/* activate handle */
	/* for now, we should probably treat warnings as errors. */
	pc_ret = pcap_activate(p);
	if (pc_ret != 0) {
		print_diag_pcap_activate(p, pc_ret, &hs);
		ret = 1;
		exit(ret);
	} else if (verbose) {
		fprintf(hs.out, "Success with no warnings from pcap_activate().\n");
	}

	/* apply bpf filter; TODO: fix quick and dirty arg parsing */
	if (argc > 2) {
		if (pcap_compile(p, &filter, argv[argc-1], 1, PCAPTOY_NETMASK_UNKNOWN) == -1) 
			 pcap_perror(p, hs.invok);
		else
			fprintf(hs.out, "Successfully compiled filter: %s\n", argv[argc-1]);

		if (pcap_setfilter(p, &filter) == -1) 
			pcap_perror(p, hs.invok);
		else
			fprintf(hs.out, "Successfuly set filter.\n");

	}
		


	/* outer loop, to force early returns from pcap_loop()*/
	/*while (1) {
		/ * TODO: last arg is ptr to arg for callback handler * /
		/ *pc_ret = pcap_loop(p, PCAPTOY_INF, handle_packet, (u_char*)&hs);* /
		/ * TODO: want _loop or _dispatch? RETURNS ARE DIFFERENT!*/
		/*pc_ret = pcap_loop(p, PCAPTOY_CAPCOUNT, handle_packet, (u_char*)&hs);* /
		pc_ret = pcap_dispatch(p, PCAPTOY_CAPCOUNT, handle_packet, (u_char*)&hs);
		if (pc_ret == -2 && verbose) {
			fprintf(fp_err, "%s: pcap_loop() broken by pcap_breakloop() before "
							"capture\n", hs.invok);
		} else if (pc_ret == -1) {
			fprintf(fp_err, "%s: pcap_loop() encountered error!\n", hs.invok);
			pcap_perror(p, hs.invok);
		} else if (pc_ret == 0 && verbose) {
			fprintf(fp_err, "%s: pcap_loop() returned all requested packets.\n", hs.invok);
		} else {
			fprintf(fp_err, "%s: pcap_loop() unknown return code! wtf?\n", hs.invok);
		}
	}A*/
	do_pcap_dispatch(p, PCAPTOY_CAPCOUNT, handle_packet, &hs);


  	return ret;
}

int do_pcap_loop	(pcap_t *p, int cnt, pcap_handler h, handler_state *phs) {
	int pc_ret = 0;
	int verbose = 1; /* TODO: replace with flag/args */
	int fatal = 0;
	/* TODO if we wanna be paranoid, we could validate FILE*'s. Let's not. */

	while (!fatal) {
		pc_ret = pcap_loop(p, cnt, h, (u_char*)phs);
		if (pc_ret == -2 && verbose) {
			fprintf(phs->err, "%s: pcap_loop() broken by pcap_breakloop() before "
							"capture\n", phs->invok);
		} else if (pc_ret == -1) {
			fprintf(phs->err, "%s: pcap_loop() encountered error!\n", phs->invok);
			pcap_perror(p, phs->invok);
			fatal = 1;
		} else if (pc_ret == 0 && verbose) {
			fprintf(phs->out, "%s: pcap_loop() returned all requested packets.\n", phs->invok);
		} else {
			fprintf(phs->err, "%s: pcap_loop() unknown return code! wtf?\n", phs->invok);
			fatal = 1;
		}
	}
	if (fatal)
		return -1;
	else
		return 1; /* should never be hit */
}

int do_pcap_dispatch(pcap_t *p, int cnt, pcap_handler h, handler_state *phs) {
	int pc_ret = 0;
	int fatal = 0;
	int verbose = 1;
	
	while (!fatal) {
		pc_ret = pcap_dispatch(p, cnt, h, (u_char*)phs);

		if (pc_ret == 0 && verbose) {
			/* TODO: Cleanly remove test code? */
			/*fprintf(phs->out, "_");*/
			fflush(phs->out); /* TODO: error handling for fflush()? */
		} else if (pc_ret == -1) { 		/* TODO: get_err? */
			fprintf(phs->err, "%s: pcap_dispatch() returned error!\n", phs->invok);
			fatal = 1;
		} else if (pc_ret == -2) {
			fprintf(phs->err, "%s: pcap_dispatch() broken by pcap_breakloop()!", phs->invok);
			fatal = 1;
		}
	}
	if (fatal)
		return -1;
	else
		return 1; /* should never be hit */
}

/* print diagnostic messages based on pcap return values. */
int print_diag_pcap_options(int pcap_ret, 
					const char* func, 
					const handler_state *phs) {
	/*int verbose = PCAPTOY_VERBOSE;*/

	if (pcap_ret != 0) {
		if (pcap_ret == PCAP_ERROR_ACTIVATED) {
			fprintf(phs->err, "%s: error: %s called on already-activated "
							"handle!\n", phs->invok, func);
		} else {
			fprintf(phs->err, "%s: error: unknown error from %s!\n", 
						phs->invok, func);
		}
	}
	return pcap_ret;
}

int print_diag_pcap_activate(pcap_t *p, 
						int pcap_ret, 
						const handler_state *phs) {
	/*char *perr = NULL;*/
	int verbose = PCAPTOY_VERBOSE;

	/* some cases will allow additional diagnostics from pcap_geterr() */
	switch (pcap_ret) {
		case 0:
			if (verbose) 
				fprintf(phs->out, "%s: success! pcap_activate().\n", phs->invok);
			break;

		case PCAP_WARNING_PROMISC_NOTSUP:
			fprintf(phs->err, "%s: pcap_activate() warns promiscuous not "
							"supported!\n", phs->invok);
			fprintf(phs->err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
			break;
		case PCAP_WARNING:
			fprintf(phs->err, "%s: error! pcap_activate claims success, "
							"but returned a warning!\n", phs->invok);
			fprintf(phs->err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
			break;
		case PCAP_ERROR_ACTIVATED:
			fprintf(phs->err, "%s: pcap_activate() returned error! Handle "
							"is already activated!\n", phs->invok);	
			break;
		case PCAP_ERROR_NO_SUCH_DEVICE:
			fprintf(phs->err, "%s: pcap_activate() returned error! No such "
							"device!\n", phs->invok);	
			fprintf(phs->err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
			break;
		case PCAP_ERROR_PERM_DENIED:
			fprintf(phs->err, "%s: pcap_activate() returned error! You "
							"don't seem to have permissions for cap "
							"device!\n", phs->invok);
			fprintf(phs->err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
			break;
		case PCAP_ERROR_RFMON_NOTSUP:
			fprintf(phs->err, "%s: pcap_activate() returned error! 802.11 "
							"RF monitor mode not supported!\n", phs->invok);
			break;
		case PCAP_ERROR_IFACE_NOT_UP:
			fprintf(phs->err, "%s: pcap_activate() returned error! "
							"Interface seems to exist, but is down!\n", phs->invok);
			break;
		case PCAP_ERROR:
		default:	
			fprintf(phs->err, "%s: pcap_activate() returned unknown error!\n",
						phs->invok);
			break;
	}


		
	return pcap_ret;
}


void handle_packet(u_char *user, const struct pcap_pkthdr *h,
					const u_char *bytes) {
	/* dummy handler TODO: flesh out; decide how layered we want 
	   out speaker/print interface */
	handler_state *phs = (handler_state*)user;
	phs->count++;

	handle_packet_print(phs, h, bytes);
	/*handle_packet_spkr(phs, h, bytes);*/
	handle_packet_spkr_array(phs, h, bytes);
}

void handle_packet_print(handler_state *phs,
							const struct pcap_pkthdr *h,
							const u_char *raw) {

	/* TODO: Need bounds checking for access to raw. A packet crafter
	   could crash this with terrible consequences since run as root. */
	/* This code might crap its pants if invoked in a non-IP 
	   ethernet environment (ie, DECNet, Appletalk. Like that's 
	   gonna happen ;).											  */
	/* pointers to the parts we're interested in, for convenience */
	/* also grab things like header length we'll need later. 	  */
	const sniff_ethernet *hdr_eth = (sniff_ethernet*)raw;
	const u_char  *eth_src = hdr_eth->ether_shost;
	const u_char  *eth_dst = hdr_eth->ether_dhost;
	const sniff_ip *hdr_ip = (sniff_ip*)(raw+ETHER_HDR_LEN);

	/* TODO: Whoops, can't really assume IP at this point. Need to look at 
	   EtherType first? */
	u_char ip_vr  = hdr_ip->ip_vhl >> 4; /* could macros in pcaptoy.h */
	u_char ip_hl  = hdr_ip->ip_vhl & 0x0f; /* header length */
	u_short ip_len = ntohs(hdr_ip->ip_len);	/* IP packet total len */
	u_short ip_flagoff = ntohs(hdr_ip->ip_off);
	u_short ip_df = (ip_flagoff & IP_DF) >> 14; /* don't frag */
	u_short ip_fragoffset = 0;
	const struct in_addr *ip_src = &(hdr_ip->ip_src);
	const struct in_addr *ip_dst = &(hdr_ip->ip_dst);
#define MAX_PADDR 32 /* TODO: Find real value. Handle IPv6 */
	char bufsrc[MAX_PADDR+1], bufdst[MAX_PADDR+1];

	/* TODO: endianness issues here? getting x806 types, when ARP is x608,
	   and x0008, when expecting x0800 for IP.	*/
	/* probably want ntohs().	*/
	const u_short *eth_typ = &hdr_eth->ether_type;
	u_short h_typ = ntohs(*eth_typ);
	memset(bufsrc, '\0', sizeof(bufsrc));
	memset(bufdst, '\0', sizeof(bufdst));
	/* TODO: This is IPv4-specific. Also, error handling */
	/* inet_net_ntop() isn't documented on linux, doesn't seem to conform to 
	   any POSIX that I'm aware of. Use inet_ntop() instead.
	   And the were damned to an eternity in IPv4					*/
	if (inet_ntop(AF_INET, (void*)ip_src, bufsrc, MAX_PADDR) == NULL) 
		perror(phs->invok);

	if (inet_ntop(AF_INET, (void*)ip_dst, bufdst, MAX_PADDR) == NULL) 
		perror(phs->invok);

	fprintf(phs->out, "%5ld: ", phs->count);
	fflush(phs->out); /* no error check XD */

	/* TODO: unspaghettify. Replace below condition with this. */
	if (h->caplen < (ETHER_HDR_LEN + ip_hl) )
		return;

	if (h->caplen > 0) {
		/* do stuff */
		fprintf(phs->out, "cap: %3d total: %5d  "
				/* 0 - "left-pad with zero" flag. 2 - minimuym field width */
				"EthTyp: %4x  "
				"EthSrc: %02X:%02X:%02X:%02X:%02X:%02X  "
				"EthDst: %02X:%02X:%02X:%02X:%02X:%02X  "
				"\n",
				h->caplen, h->len,
				h_typ,
				eth_src[0], eth_src[1], eth_src[2], eth_src[3], eth_src[4], eth_src[5],
				eth_dst[0], eth_dst[1], eth_dst[2], eth_dst[3], eth_dst[4], eth_dst[5]
		);
		if (h_typ >= 0x0800) {
			switch (h_typ) {
			  case ETYPE_ARP:
				printf("\t ARP!\n"); /* TODO: details? */
				break;
			  case ETYPE_IPV4:
				ip_flagoff = ntohs(hdr_ip->ip_off);
				ip_fragoffset = ip_flagoff & IP_OFFMASK; /* grab frag offset */
				printf("\tIPv%d  len: %4d DontFrag:%d FragOff: %d Src: %s Dst: %s\n", ip_vr, ip_len, 
															ip_df, ip_fragoffset, bufsrc, bufdst);
				break;
			  case ETYPE_IPV6:	
			  case ETYPE_RARP:	
			  default:
				printf("Unknown EtherType! Weird, check it out!\n");
				/*exit(1);*/	/* TODO:remove bailout on unknown EtherType? */
			} 
		}else {
				printf("no EtherType; payload size %d\n", h_typ);
		}
	}
	else {
		perror("pcap_pkthdr caplen of <= 0!");
	}
}

void handle_packet_spkr(handler_state *phs, 
							const struct pcap_pkthdr *h,
							const u_char *raw) {
#ifdef __BSD_SPEAKER__
/* TODO: Very rough proof of concept. Refine. */
	tone_t t;

	/* TODO: Probably makes more sense to keep descriptor in 
	   handler_state rather than open at every callback */
   	/*fd = open("/dev/speaker", O_WRONLY);*/
	if (phs->fd_spkr == -1) {
		perror("open() of /dev/speaker failed! ");
		exit(1); /* TODO: unspaghettify */
	}
	else {
		/* see man spkr */
		/* TODO: check length! Might need to pass an arg, maybe pcap_pkthdr */
		   
		t.duration = 1;
		t.frequency = testfreq; /* test with A */

		if (ioctl(phs->fd_spkr, SPKRTONE, &t) == -1) {
			perror("ioctl() failed! ");
		}
		else {
			/*testfreq += 10;*/
			testfreq += rand() % 16000;
		}
	}
	/*close(fd);*/ /* TODO: remove when fd in handler_state */
#endif  /* __BSD_SPEAKER__ */
}
void handle_packet_spkr_array(handler_state *phs, 
							const struct pcap_pkthdr *h,
							const u_char *raw) {
	/* tone for AF, encode src and dst addy's/ports, tone for 
	   proto (TCP/UDP; start with TCP), encode payload */
	/* TODO: How big to make tone_t array? Dynamically allocate? Figure out
	   a good maximum for static alloc? Start with 2048 I guess */
	/* decl */
	const sniff_ethernet *hdr_eth = NULL;
	const u_char *eth_src = NULL;
	const u_char *eth_dst = NULL;
	const u_short *eth_typ = NULL; /* ptr to type field */
	u_short h_typ = 0; /* host-order type */
	const sniff_ip *hdr_ip = NULL;
	bpf_u_int32 ip_hl = 0;
	u_short ip_flagoff = 0;	/* flags, frag offset field */
	u_short ip_fragoffset = 0;
	u_char ip_proto = 0;
	const sniff_icmp *hdr_icmp = NULL;
	u_char icmp_type = 0;

/* TODO: #defines for EtherType tones here */
#define MAX_TONES 		2048
#define DUR_ETYPE		2	/* duration for EtherType field freq */
#define DUR_IPPROTO		2 /* TCP, UDP, ICMP, etc */
#define DUR_FRAGMENTS   3 /* fragment offset */
#define DUR_ICMP		4 
#define FREQ_ARP 		660   /* E5 (above A) */
#define FREQ_RARP		1319  /* E6 */
#define FREQ_IPV4		440
#define FREQ_IPV6		880   /* A5 */
#define FREQ_ICMP_REQ	2217 /* D7	*/
#define FREQ_ICMP_RES	1661 /* C#7	*/
#define FREQ_TCP		494  /* C5 	*/
/*#define FREQ_UDP		392*/ /* G 	*/
#define FREQ_UDP		554  /* C# 	*/
#define FREQ_UNKNOWN	262 /* C4 	*/
	int tncnt = 0;
	tone_t tones[MAX_TONES+1];

	/* init */
	memset(tones, '\0', sizeof(tones));
	tones[MAX_TONES].duration = 0; /* terminates array for ioctl */

	/* silently abort at any step if caplen is too short to complete. */
	/* specifically, we need to at least read the IP header length to 
	   get anything worth generating a tone. It's in first octet of IP */
	if (h->caplen < ETHER_HDR_LEN+1)
		return;
	hdr_eth = (sniff_ethernet*) raw;
	eth_src = hdr_eth->ether_shost;
	eth_dst = hdr_eth->ether_dhost;
	eth_typ = &(hdr_eth->ether_type);

	/* let's not bother with a tone for ethernet. */

	/* Here, let's grab Ether Type. Check for ARP? How to handle tone generation and 
	   quick return if we get ARP or something other than IPv4? Maybe have a separate
	   block here to build array then exit? Switch statement? */
	h_typ = ntohs(*eth_typ);
	tones[tncnt].duration = DUR_ETYPE;
	switch (h_typ) {
		case ETYPE_ARP:
			tones[tncnt++].frequency = FREQ_ARP;
			/*tones[tncnt].duration = 0;*/ /* terminate array */
			break;
	 	case ETYPE_RARP:
			tones[tncnt++].frequency = FREQ_RARP;
			/*tones[tncnt].duration = 0;*/
			break;
		case ETYPE_IPV4: { /* This isn't going to be pretty */
			/* make sure the rest of IP header is contained in capture (paranoia) */
			printf("IPv4!\n"); /* DEBUG */

			hdr_ip = (sniff_ip*)(raw+ETHER_HDR_LEN);
			ip_hl = (bpf_u_int32)hdr_ip->ip_vhl & 0x0f; /* grab second nibble */
			ip_hl *= 4; /* convert from 32-bit words to octets for easier use */

			if (h->caplen < (ETHER_HDR_LEN + ip_hl) )
				break;
			tones[tncnt++].frequency = FREQ_IPV4;

			tones[tncnt].duration = DUR_IPPROTO;
			/* chirp for fragmented IP packets */
			ip_flagoff = ntohs(hdr_ip->ip_off);
			ip_fragoffset = ip_flagoff & IP_OFFMASK; /* grab frag offset */
			if (ip_fragoffset) {
				printf("Frag!\n"); /* DEBUG */
				/* override DUR_IPPROTO, special case */
				tones[tncnt].duration = DUR_FRAGMENTS; /* TODO: increment looks questionable */
				tones[tncnt++].frequency = FREQ_IPV4 << ip_fragoffset; /* octaves of A440 */
			}

			/* grab IP proto. We'll use it for logic in a nested switch below. */
			ip_proto = hdr_ip->ip_p;
			/* TODO: also grab src/dst in_addr's? Not sure how to encode them. */
			
			switch (ip_proto) { /* these are defined in <netinet/in.h> */
				case IPPROTO_ICMP: {
				printf("ICMP! \n"); /* DEBUG */
					if (h->caplen >= (ETHER_HDR_LEN + ip_hl + ICMP_HDR_LEN)) {
						/* want something ping-y. break up ICMP types, req/resp, etc? */
						/* grab ICMP type. */
						hdr_icmp = (sniff_icmp*)(raw + ETHER_HDR_LEN + ip_hl); /* likely problem here */
						icmp_type = hdr_icmp->type; /* TODO consider removing variable */
						tones[tncnt].duration = DUR_ICMP;
						switch (icmp_type) {
							case PCT_ICMP_ECHO:
								printf("Echo!\n"); /* DEBUG */
								tones[tncnt++].frequency = FREQ_ICMP_REQ;
								break;
							case PCT_ICMP_ECHOREPLY:
								printf("Reply!\n"); /* DEBUG */
								tones[tncnt++].frequency = FREQ_ICMP_RES;
								break;
							default: /* TODO: handle any others? */	
								printf("Unknown ICMP! %d\n", icmp_type); /* DEBUG */
								break; /* TODO: iffy. */
						} /* end switch icmp type */
					}
					break;
			   } /* end case IPPROTO_ICMP */
				case IPPROTO_TCP:
					printf("TCP!\n"); /* DEBUG */
					tones[tncnt++].frequency = FREQ_TCP;
					break;
				case IPPROTO_UDP:
					printf("UDP!\n"); /* DEBUG */
					tones[tncnt++].frequency = FREQ_UDP;
					break;
				default:
					/* TODO: make it noticeable if we get unknown protocol. */
					printf("Uknown IP Protocol!\n"); /* DEBUG */
					break;
			} /* end switch ip_proto */

			/*tones[tncnt].duration = 0;*/ /* terminate array */
			break;
		 } /* end case ETYPE_IPV4 */
		case ETYPE_IPV6:
			printf("IPV6!\n"); /* DEBUG */
			tones[tncnt++].frequency = FREQ_IPV6;
			/*tones[tncnt].duration = 0;*/
			break;
		default:
			printf("Unknown EtherType!\n");
			tones[tncnt++].frequency = FREQ_UNKNOWN;
			
			break;
	} /* end switch h_typ (EtherType */

	/* TODO: Maybe should terminate array here instead of within switch statements. 
	 * Less likelihood of error, less code. Can assume any code that added to the 
	 * array incremented the index. */
	/* That way we can break when we run out of header, and still play the tones. */
	tones[tncnt].duration = 0; /* terminate array */
	/* array should be prepared, now send to ioctl. */

#ifdef __BSD_SPEAKER__
	if (ioctl(phs->fd_spkr, SPKRTUNE, tones) == -1)
		perror("ioctl() failed!");
#endif  /* __BSD_SPEAKER__ */
#ifdef __LINUX__
	output_array_portaudio(phs, tones);
#endif /* __LINUX__ */


	/* make sure the rest of IP header is contained in capture (paranoia) */
	/*if (h->caplen < (ETHER_HDR_LEN + ip_hl) )
		return; moved this into switch above  */
}

/* linux output function */
void output_array_portaudio(handler_state *phs, tone_t *tones) {
#ifdef __LINUX__
#define FOO_SIZE 32
	/*float foo_sample[FOO_SIZE];
	int i = 0;
	for (i = 0; i < FOO_SIZE; i++)
		if (i % 2)
			foo_sample[i] = (float)0.01*i*5;
		else
			foo_sample[i] = (float)0.001*i*5;
	Pa_WriteStream(phs->pa, foo_sample, FOO_SIZE);*/

	/* TODO: put a loop around this block; loop over tones array. */
	int i = 0, j = 0, r = 0;
	float buf[FRAMES_PER_BUFFER][2];/* stereo; two chans */
	int lphase = 0, rphase = 0;
	int lphaseinc = 1, rphaseinc = 3;

	tone_t footone = {220, 3};
	lphase = SAMPLE_RATE / footone.frequency;
	rphase = SAMPLE_RATE / footone.frequency;
	/* get number of buffer writes, based on millisecond duration */
	printf("duration in seconds: %f\n", ((float)footone.duration) / 1000);
	printf("duration times SAMPLE_RATE: %f\n", ((float)footone.duration / 1000) * SAMPLE_RATE);
	printf("(d * rate) / FRAMES_PER_BUFFER: %f\n", (((float)footone.duration/1000)*SAMPLE_RATE) 
														/ FRAMES_PER_BUFFER);
	int writecount = (int)( ((((float)footone.duration) / 1000) * SAMPLE_RATE) / FRAMES_PER_BUFFER);
	/*writecount = 1;*/
	printf("writecount: %d duration: %d SAMPLE_RATE:%d FRAMES_PER_BUFFER: %d\n", 
				writecount, footone.duration, SAMPLE_RATE, FRAMES_PER_BUFFER);
	for (i = 0; i < writecount; i++) {
		for (j = 0; j < FRAMES_PER_BUFFER; j++) {
			buf[j][0] = phs->sine[lphase];
			buf[j][1] = phs->sine[rphase];
			lphase += lphaseinc;
			if (lphase >= WAVETABLE_SIZE)
				lphase -= WAVETABLE_SIZE;
			rphase += rphaseinc;
			if (rphase >= WAVETABLE_SIZE)
				rphase -= WAVETABLE_SIZE;

			r = Pa_WriteStream(phs->pa, buf, FRAMES_PER_BUFFER);
			if (r != paNoError)
				printf("Pa_WriteStream() error in loop: %s\n", Pa_GetErrorText(r));
		} /* ***** TODO: misplaced brace? Shouldn't I write AFTER this loop, not within it? **** TODO ****** */
	}
#endif
}

int InitAudio(handler_state *phs) {

#ifdef __LINUX__
	return InitAudioLinux(phs);
#else
	return 1;
#endif
}

void DeInitAudio() {
#ifdef __LINUX__
	DeInitAudioLinux();
#endif
}

#ifdef __LINUX__
int InitAudioLinux(handler_state *phs) {
#define NUM_CHANS 1
#define PA_SAMPLE_TYPE 0 /* ??? */

	int i = 0;
	int r = 0;
	PaStreamParameters inParams, outParams;
	const PaDeviceInfo *pdevinfo = NULL;
	memset(&inParams, sizeof(inParams), '0');
	memset(&outParams, sizeof(outParams), '0');

	r = Pa_Initialize(); /* must come first */
	if (r != paNoError) {
		printf("Error: Pa_Initialize() error: %s\n", Pa_GetErrorText(r));
		return 0;
	}

	/* TODO: could invalid device be from input device? What's appropriate for NONE? */

	/* Can we just pass NULL for input params?*/
	inParams.device = r = Pa_GetDefaultInputDevice();
	if (inParams.device < 0) {
		printf("error! from Pa_GetDefaultInputDevice(): %s\n", Pa_GetErrorText(r));
	}
	inParams.channelCount = NUM_CHANS;
	pdevinfo = Pa_GetDeviceInfo(inParams.device);
	if (pdevinfo == NULL) {
		printf("error! from Pa_GetDeviceInfo()\n");
		return 0;
	}
	inParams.sampleFormat = pdevinfo->defaultSampleRate; /* ??? */
	inParams.suggestedLatency = pdevinfo->defaultHighInputLatency;
	inParams.hostApiSpecificStreamInfo = NULL;

	outParams.device = r = Pa_GetDefaultOutputDevice();
	if (outParams.device < 0) {
		printf("error! from Pa_GetDefaultOutputDevice(): %s\n", Pa_GetErrorText(r));
	}
	outParams.channelCount = NUM_CHANS;
	pdevinfo = Pa_GetDeviceInfo(outParams.device);
	if (pdevinfo == NULL) {
		printf("error! from Pa_GetDeviceInfo()\n");
		return 0;
	}
	outParams.sampleFormat = pdevinfo->defaultSampleRate; /* ??? */
	printf("Getting portaudio latency...\n");
	outParams.suggestedLatency = pdevinfo->defaultHighOutputLatency;
	outParams.hostApiSpecificStreamInfo = NULL;


	/* TODO: need PaStream object. Ugh, don't wanna 
	 * do a global. Need to pass around another state object?
	 * Can it be the handler_state? Maybe so, since will need
	 * it in the handler function. */
	/*r = Pa_OpenStream(&(phs->pa),
			/ *&inParams,* /		/ *input parameters * /
			NULL,
			&outParams, 
			/ *SAMPLE_RATE,* /
			outParams.sampleFormat,
			FRAMES_PER_BUFFER,
			paClipOff,
			NULL, 		/ * callback ptr * /
			NULL);*/		/* callback userdata */
	r = Pa_OpenDefaultStream(&(phs->pa),
	  		0, /* input chans */
			2, /* output chans */
			paFloat32, /* or specify eg paInt24 */
			SAMPLE_RATE,
			0,
			NULL,
			NULL);
	if (r != paNoError) {
		printf("Error: Pa_OpenStream() error!: %s\n", Pa_GetErrorText(r));
		return 0;
	}

	r = Pa_StartStream(phs->pa);
	if (r != paNoError) {
		printf("Error, Pa_StartStream() error: %s\n", Pa_GetErrorText(r));
		return 0;
	}

	/* build a wave table for tone generation. Copied from portaudio examples */
	if (DEBUG) fprintf(phs->err, "Building wavetable...\n");
	for (i = 0; i < WAVETABLE_SIZE; i++) {
		phs->sine[i] = (float)sin( (double)i / (double)WAVETABLE_SIZE * M_PI * 2.);
		if (DEBUG) fprintf(phs->err, "%d: %f\n", i, phs->sine[i]);
	}
			

	return 1;
}

void DeInitAudioLinux() {
	Pa_Terminate();

}
#endif
@


1.22
log
@syntax
@
text
@d18 1
d108 1
a108 1
	#define WAVETABLE_SIZE 200
d789 1
a789 1
#define FOO_SIZE 1024
d804 4
a807 1
	tone_t footone = {440, 200};
d814 1
d831 1
a831 1
		}
d919 1
a919 1
			paInt24, /* or specify eg paInt24 */
d921 1
a921 1
			FRAMES_PER_BUFFER,
d936 2
a937 1
	for (i = 0; i < WAVETABLE_SIZE; i++)
d939 3
@


1.21
log
@crappy phased sine generation
Needs analysis
@
text
@d814 1
a814 1
			buf[j][0] = phs->sine[lphase]);
@


1.20
log
@Added portaudio init code and output stub for linux. Added ifdef's and typedef for Linux
to handle BSD tone_t struct.
@
text
@d45 1
d105 3
d109 4
d764 3
a766 2
	/* TODO: Maybe should terminate array here instead of within switch statements. Less likelihood
	   of error, less code. Can assume any code that added to the array incremented the index. */
d788 2
a789 2
#define FOO_SIZE 256
	float foo_sample[FOO_SIZE];
d792 5
a796 3
		foo_sample[i] = (float)220;

	Pa_WriteStream(phs->pa, foo_sample, FOO_SIZE);
d798 30
a849 2
#define SAMPLE_RATE 44100
#define FRAMES_PER_BUFFER paFramesPerBufferUnspecified /* TODO */
d851 1
d913 1
a913 1
			1, /* output chans */
d929 4
@


1.19
log
@Fixed IP header length issue (forgot was in words, not octets). Added IP protocol beeps for TCP and UDP.
@
text
@d43 5
d103 4
d110 9
d140 5
d185 1
d202 4
d562 1
a562 1
				exit(1);	/* TODO:remove bailout on unknown EtherType? */
a607 1
#ifdef __BSD_SPEAKER__
d628 6
a633 6
#define DUR_ETYPE		5	/* duration for EtherType field freq */
#define DUR_IPPROTO		5 /* TCP, UDP, ICMP, etc */
#define DUR_FRAGMENTS	1   /* fragment offset */
#define DUR_ICMP		10 
#define FREQ_ARP 		660 /* E5 (above A) */
#define FREQ_RARP		1320
d635 7
a641 6
#define FREQ_IPV6		880
#define FREQ_ICMP_REQ	4186 /* might want higher octave even */
#define FREQ_ICMP_RES	2093
#define FREQ_TCP		523
#define FREQ_UDP		392 /* G */
#define FREQ_UNKNOWN	262 /* low C */
d750 1
a750 1
			printf("Unknown EtherType!");
d761 2
d765 4
a773 1
#endif  /* __BSD_SPEAKER__ */
d775 123
@


1.18
log
@Started Switch Statement of Doom for IP protocols and ICMP types. Control flow problems; work in progress.
@
text
@d602 1
a602 1
#define DUR_IPPROTO		100 /* TCP, UDP, ICMP, etc */
d612 1
a612 1
#define FREQ_UDP		392
d618 1
a631 2
	hdr_ip = (sniff_ip*)(raw+ETHER_HDR_LEN);
	ip_hl = (bpf_u_int32)hdr_ip->ip_vhl & 0x0f; /* grab second nibble */
d649 6
d659 1
d664 4
a667 2
				tones[tncnt].frequency = FREQ_IPV4 << ip_fragoffset; /* octaves of A440 */
				tones[tncnt++].duration = DUR_FRAGMENTS; /* TODO: increment looks questionable */
d676 2
a677 1
					if (h->caplen >= ETHER_HDR_LEN + ip_hl + ICMP_HDR_LEN) {
d680 1
a680 1
						hdr_icmp = (sniff_icmp*)(hdr_ip + ip_hl);
d685 1
d689 1
d693 2
a694 1
								break;
d700 2
d704 2
a706 2


d709 1
d717 1
d722 1
@


1.17
log
@very sparse handling of IPv6; still bailing on it. Indent changes. Need to rethink design a bit; maybe get
analysis code out of print function, so it can be used for speaker function. Or maybe get print code out. Or both.
@
text
@d1 5
d14 7
d55 8
d271 1
a271 1
		if (pcap_compile(p, &filter, argv[argc-1], 1, PCAP_NETMASK_UNKNOWN) == -1) 
d449 2
a450 1
	handle_packet_spkr(phs, h, bytes);
d457 1
a457 1
	/* TODO: Meed bounds checking for access to raw. A packet crafter
d476 1
d502 4
d525 4
a528 1
				printf("\tIPv%d  len: %4d DontFrag:%d Src: %s Dst: %s\n", ip_vr, ip_len, ip_df, bufsrc, bufdst);
d580 144
a723 1
	
@


1.16
log
@Added filtering with bpf filter syntax - works just like tcpdump.
@
text
@d7 1
d327 2
a328 1
			fprintf(phs->out, "_");
d435 3
d447 3
d455 4
d465 11
d493 16
a508 10
		switch (h_typ) {
			case ETYPE_ARP:
			printf("\t ARP!\n"); /* TODO: details? */
			break;
			case ETYPE_IP:
			printf("\tIPv%d  len: %4d DontFrag:%d\n", ip_vr, ip_len, ip_df);
			break;
			default:
			printf("Unknown EtherType! Weird, check it out!\n");
			exit(1);	/* TODO:remove bailout on unknown EtherType? */
@


1.15
log
@Added IP header parsing and printing.
@
text
@d129 1
d132 1
d248 16
@


1.14
log
@CPP logic for BSD speaker
@
text
@d122 1
a122 1
	int framelen = 32; 
d415 3
d419 1
d421 14
a434 1
	const u_char *eth_src = hdr_eth->ether_shost;
d436 1
a436 1
	fprintf(phs->out, "%5ld.", phs->count);
d443 1
d445 1
d448 15
a462 2
				eth_src[0], eth_src[1], eth_src[2], eth_src[3], eth_src[4], eth_src[5]
				);
@


1.13
log
@Added #include "pcaptoy.h" for packet header structs.
@
text
@d12 1
d17 1
d26 1
d88 1
a88 1
					const u_char *bytes);
d93 1
a93 1
							const u_char *bytes);
d96 1
a96 1
							const u_char *bytes);
d99 1
a99 1
							const u_char *bytes);
d414 6
a419 2
							const u_char *bytes) {
	fprintf(phs->out, "%ld.", phs->count);
d424 7
a430 2


d439 2
a440 1
							const u_char *bytes) {
a442 1
	int fd = 0;
d447 1
a447 1
	if (fd == -1) {
d449 1
d467 1
d471 1
a471 1
							const u_char *bytes) {
@


1.12
log
@merged in ifdef's for OS-specific headers on OpenBSD, FreeBSD, NetBSD.
@
text
@d27 1
a27 1
/*#include "pcaptoy.h"*/
d88 9
a96 2
void handle_packet_print(const u_char *bytes);
void handle_packet_spkr(handler_state *phs, const u_char *bytes);
d405 7
d413 9
a421 4
	if (!fflush(phs->out)) {
		/* TODO: use strerror and our phs->out stream? */
		/* sloppy error reporting; flesh out */
		/*perror(phs->invok);*/
a422 2

	handle_packet_spkr(phs, bytes);
d425 3
a427 2

void handle_packet_spkr(handler_state *phs, const u_char *bytes) {
d455 5
@


1.11
log
@speaker interface stubbed, tested, working. Just using dummy tones; not reading
packets yet.
@
text
@d8 4
d13 1
a13 3

/* needed for u_char? */
/*#include <sys/types.h>*/
d16 2
d23 4
d424 1
a424 1
		t.duration = 5;
d431 2
a432 1
			testfreq += 10;
@


1.10
log
@Added fflush() call for diagnostic output in do_pcap_dispatch():w
@
text
@d3 1
d8 2
a11 1
 
d19 2
d62 3
a64 2
	FILE *out; 	/* normally stdout 	*/
	FILE *err; 	/* stderr 			*/
d79 4
d87 3
d120 1
d291 1
a291 1
			fflush(phs->err); /* TODO: error handling for fflush()? */
a390 1

d396 31
@


1.9
log
@Added fflush() call to fix buffering issues (was stdio, not pcap).
replaced direct instances of stdout, stderr streams with userdata struct members.
@
text
@d278 1
@


1.8
log
@implemented pcap_loop and pcap_dispatch handling code; move into their own functions.
Using pcap_dispatch for now.:w
@
text
@d23 1
a23 1
#define PCAPTOY_CAPCOUNT	2000
d27 2
d57 4
a61 1
	char invok[PATH_MAX+1]; /* TODO: replace w/ runtime pathconf() and dynamic alloc */
d82 2
a83 2
	FILE *fp_log = stdout;
	FILE *fp_err = stderr;
d106 2
d111 2
a112 2
		fprintf(fp_err, "%s: No interface specified!\n", hs.invok);
		fprintf(fp_err, "usage: %s <interface>\n", hs.invok);
d119 1
a119 1
		fprintf(fp_log, "Initializing, getting pcap handle for >%s<\n",
d126 2
a127 2
		fprintf(fp_err, "pcap_create() failed!: \n");
		fprintf(fp_err, errbuf);
d129 1
a129 1
			fprintf(fp_log, "pcap_create() error, bailing\n");
d135 1
a135 1
		fprintf(fp_log, "pcap_create() success, continuing.\n");
d145 1
a145 1
		fprintf(fp_err, "%s: can't set snapshot length, bailing!\n", hs.invok);
d149 1
a149 1
		fprintf(fp_log, "Successfully set snapshot len to %d, continuing...\n",
d158 1
a158 1
		fprintf(fp_err, "%s: can't set promisc flag, bailing!\n", hs.invok);
d162 1
a162 1
		fprintf(fp_log, "Successfully set promiscuous flag to %d, "
d180 1
a180 1
		fprintf(fp_err, "%s: can't set read timeout, bailing!\n", hs.invok);
d184 1
a184 1
		fprintf(fp_log, "Successfully set read timeout to %d, continuing...\n",
d195 1
a195 1
		fprintf(fp_err, "%s: can't set pcap buffer size, bailing!\n", hs.invok);
d199 1
a199 1
		fprintf(fp_log, "Successfully set pcap buffer size to %d, "
d212 1
a212 1
		fprintf(fp_log, "Success with no warnings from pcap_activate().\n");
a242 2
	FILE *fp_log = stdout;
	FILE *fp_err = stderr;
d244 1
d249 1
a249 1
			fprintf(fp_err, "%s: pcap_loop() broken by pcap_breakloop() before "
d252 1
a252 1
			fprintf(fp_err, "%s: pcap_loop() encountered error!\n", phs->invok);
d256 1
a256 1
			fprintf(fp_log, "%s: pcap_loop() returned all requested packets.\n", phs->invok);
d258 1
a258 1
			fprintf(fp_err, "%s: pcap_loop() unknown return code! wtf?\n", phs->invok);
a269 2
	FILE *fp_log = stdout;
	FILE *fp_err = stderr;
d277 1
a277 1
			fprintf(fp_log, "_");
d279 1
a279 1
			fprintf(fp_err, "%s: pcap_dispatch() returned error!\n", phs->invok);
d282 1
a282 1
			fprintf(fp_err, "%s: pcap_dispatch() broken by pcap_breakloop()!", phs->invok);
a296 2
	/*FILE *fp_log = stdout;*/
	FILE *fp_err = stderr;
d300 1
a300 1
			fprintf(fp_err, "%s: error: %s called on already-activated "
d303 1
a303 1
			fprintf(fp_err, "%s: error: unknown error from %s!\n", 
a313 1

a314 2
	FILE *fp_log = stdout;
	FILE *fp_err = stderr;
d320 1
a320 1
				fprintf(fp_log, "%s: success! pcap_activate().\n", phs->invok);
d324 1
a324 1
			fprintf(fp_err, "%s: pcap_activate() warns promiscuous not "
d326 1
a326 1
			fprintf(fp_err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
d329 1
a329 1
			fprintf(fp_err, "%s: error! pcap_activate claims success, "
d331 1
a331 1
			fprintf(fp_err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
d334 1
a334 1
			fprintf(fp_err, "%s: pcap_activate() returned error! Handle "
d338 1
a338 1
			fprintf(fp_err, "%s: pcap_activate() returned error! No such "
d340 1
a340 1
			fprintf(fp_err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
d343 1
a343 1
			fprintf(fp_err, "%s: pcap_activate() returned error! You "
d346 1
a346 1
			fprintf(fp_err, "%s:\tDetails: >%s<\n", phs->invok, pcap_geterr(p));
d349 1
a349 1
			fprintf(fp_err, "%s: pcap_activate() returned error! 802.11 "
d353 1
a353 1
			fprintf(fp_err, "%s: pcap_activate() returned error! "
d358 1
a358 1
			fprintf(fp_err, "%s: pcap_activate() returned unknown error!\n",
d376 1
a376 1
	printf("%ld.", phs->count);
d378 5
@


1.7
log
@switching from pcap_loop() to pcap_dispatch. Tweaking packet count and read timeout.
@
text
@d5 1
d56 1
d60 1
a60 1
int print_diag_pcap_options(int pcap_ret, const char *func, const char *invok);
d63 1
a63 1
int print_diag_pcap_activate(pcap_t *p, int pcap_ret, const char *invok);
d69 4
d99 2
d104 2
a105 2
		fprintf(fp_err, "%s: No interface specified!\n", argv[0]);
		fprintf(fp_err, "usage: %s <interface>\n", argv[0]);
d135 1
a135 1
	print_diag_pcap_options(pc_ret, funcbuf, argv[0]);
d138 1
a138 1
		fprintf(fp_err, "%s: can't set snapshot length, bailing!\n", argv[0]);
d149 1
a149 1
	print_diag_pcap_options(pc_ret, funcbuf, argv[0]);
d151 1
a151 1
		fprintf(fp_err, "%s: can't set promisc flag, bailing!\n", argv[0]);
d171 1
a171 1
	print_diag_pcap_options(pc_ret, funcbuf, argv[0]);
d173 1
a173 1
		fprintf(fp_err, "%s: can't set read timeout, bailing!\n", argv[0]);
d186 1
a186 1
	print_diag_pcap_options(pc_ret, funcbuf, argv[0]);
d188 1
a188 1
		fprintf(fp_err, "%s: can't set pcap buffer size, bailing!\n", argv[0]);
d201 1
a201 1
		print_diag_pcap_activate(p, pc_ret, argv[0]);
d209 5
a213 5
	while (1) {
		/* TODO: last arg is ptr to arg for callback handler */
		/*pc_ret = pcap_loop(p, PCAPTOY_INF, handle_packet, (u_char*)&hs);*/
		/* TODO: want _loop or _dispatch? RETURNS ARE DIFFERENT!*/
		/*pc_ret = pcap_loop(p, PCAPTOY_CAPCOUNT, handle_packet, (u_char*)&hs);*/
d217 1
a217 1
							"capture\n", argv[0]);
d219 2
a220 2
			fprintf(fp_err, "%s: pcap_loop() encountered error!\n", argv[0]);
			pcap_perror(p, argv[0]);
d222 1
a222 1
			fprintf(fp_err, "%s: pcap_loop() returned all requested packets.\n", argv[0]);
d224 1
a224 1
			fprintf(fp_err, "%s: pcap_loop() unknown return code! wtf?\n", argv[0]);
d226 2
a227 1
	}
d233 55
d291 1
a291 1
					const char *invok) {
d299 1
a299 1
							"handle!\n", invok, func);
d302 1
a302 1
						invok, func);
d310 1
a310 1
						const char *invok) {
d321 1
a321 1
				fprintf(fp_log, "%s: success! pcap_activate().\n", invok);
d326 2
a327 2
							"supported!\n", invok);
			fprintf(fp_err, "%s:\tDetails: >%s<\n", invok, pcap_geterr(p));
d331 2
a332 2
							"but returned a warning!\n", invok);
			fprintf(fp_err, "%s:\tDetails: >%s<\n", invok, pcap_geterr(p));
d336 1
a336 1
							"is already activated!\n", invok);	
d340 2
a341 2
							"device!\n", invok);	
			fprintf(fp_err, "%s:\tDetails: >%s<\n", invok, pcap_geterr(p));
d346 2
a347 2
							"device!\n", invok);
			fprintf(fp_err, "%s:\tDetails: >%s<\n", invok, pcap_geterr(p));
d351 1
a351 1
							"RF monitor mode not supported!\n", invok);
d355 1
a355 1
							"Interface seems to exist, but is down!\n", invok);
d360 1
a360 1
						invok);
@


1.6
log
@added pcap_loop() simple error handling
@
text
@d22 1
d24 1
a24 1
#define PCAPTOY_TIMEOUT		5 	/* ms? */
d52 5
d77 1
d92 1
d200 18
a217 13

	/* TODO: last arg is ptr to arg for callback handler */
	pc_ret = pcap_loop(p, PCAPTOY_INF, handle_packet, NULL);
	if (pc_ret == -2 && verbose) {
		fprintf(fp_err, "%s: pcap_loop() broken by pcap_breakloop() before "
						"capture\n", argv[0]);
	} else if (pc_ret == -1) {
		fprintf(fp_err, "%s: pcap_loop() encountered error!\n", argv[0]);
		pcap_perror(p, argv[0]);
	} else if (pc_ret == 0 && verbose) {
		fprintf(fp_err, "%s: pcap_loop() returned all requested packets.\n", argv[0]);
	} else {
		fprintf(fp_err, "%s: pcap_loop() unknown return code! wtf?\n", argv[0]);
d228 2
a229 2
	int verbose = PCAPTOY_VERBOSE;
	FILE *fp_log = stdout;
d247 1
a247 1
	char *perr = NULL;
d310 4
a313 1
	printf(".");
@


1.5
log
@pcap_loop() call in place; callback working. Needs pcap_loop() error handling.
@
text
@d23 1
d76 1
a76 1
	int read_timeout  	= 500; /* read timeout in ms */
d195 3
a197 2
	/*if (pc_ret == -2 && verbose) {
		fprintf(fp_err, "pcap_loop() broken by pcap_breakloop() before capture\n");
d199 7
a205 1
*/
@


1.4
log
@added newline to console messages.
Added OpenBSD-specific include of <pcap.h>
@
text
@d6 4
d14 1
a14 1
#endif /* __OPENBSD */
d21 1
d56 4
d191 9
d283 9
@


1.3
log
@finished initialization/error handling code.
TODO: grab and handle packets. Use callbacks?
@
text
@d5 4
d10 1
d20 4
d248 1
a248 1
							"RF monitor mode not supported!", invok);
d252 1
a252 1
							"Interface seems to exist, but is down!", invok);
@


1.2
log
@cleaned up commented code left over from splitting pcap diagnostic
to a separate function
@
text
@d8 10
a17 1
#define MAX_FUNC_LEN 1024 /* max length of function name strings */
d37 4
a40 1
int print_diag_pcapreturn(int pcap_ret, const char *func, const char *invok);
d43 1
a43 1
	int verbose = 1; /* TODO: arg */
d56 3
a58 1
	int promisc  = 0;  /* TODO: command-line arg */
d100 1
a100 1
	print_diag_pcapreturn(pc_ret, funcbuf, argv[0]);
d102 1
a102 1
		print_diag_pcapreturn(pc_ret, funcbuf, argv[0]);
d111 4
a115 1
		print_diag_pcapreturn(pc_ret, funcbuf, argv[0]);
d120 1
a120 1
		fprintf(fp_log, "Successfully set primiscuous flag to %d, "
d124 38
d163 9
d177 1
a177 1
int print_diag_pcapreturn(int pcap_ret, 
d180 1
a180 1
	int verbose = 1;
d195 61
@


1.1
log
@Initial revision
@
text
@a87 8
		/*if (pc_ret == PCAP_ERROR_ACTIVATED) {
			fprintf(fp_err, "%s: error: pcap_set_snaplen(%d, %d) called on "
					"already-activated handle!\n", argv[0], (int)p, framelen);
		} else {
			fprintf(fp_err, "%s: error: unknown error from "
							"pcap_set_snaplen(%d, %d)!\n", 
						argv[0], (int)p, framelen);
		} */
d93 1
a93 1
		fprintf(fp_log, "Successfully set snapshot len to %d, continuing\n",
d97 10
a106 2
	/*if (pc_ret != 0) {
		if (pc_ret == PCAP_ERROR_ACTI */
@
